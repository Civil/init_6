From 2a1b86b6f52f500277308cffcfffb8e971b116a8 Mon Sep 17 00:00:00 2001
From: Nai Xia <nai.xia@gmail.com>
Date: Sun, 13 May 2012 20:22:43 +0800
Subject: [PATCH 2/2] UKSM: add VM_MERGEABLE to vm_flags before vma_merge()

---
 include/linux/uksm.h |   23 +++++++++++++++++++++++
 mm/mmap.c            |    4 ++++
 mm/uksm.c            |    6 +-----
 3 files changed, 28 insertions(+), 5 deletions(-)

diff --git a/include/linux/uksm.h b/include/linux/uksm.h
index 27b80bf..a2b78bc 100644
--- a/include/linux/uksm.h
+++ b/include/linux/uksm.h
@@ -74,6 +74,20 @@ static inline void uksm_cow_pte(struct vm_area_struct *vma, pte_t pte)
 		vma->uksm_vma_slot->pages_cowed++;
 }
 
+static inline int uksm_flags_can_scan(unsigned long vm_flags)
+{
+	return !(vm_flags & (VM_PFNMAP | VM_IO  | VM_DONTEXPAND |
+				  VM_RESERVED  | VM_HUGETLB | VM_INSERTPAGE |
+				  VM_NONLINEAR | VM_MIXEDMAP | VM_SAO |
+				  VM_SHARED  | VM_MAYSHARE | VM_GROWSUP
+				  | VM_GROWSDOWN));
+}
+
+static inline void uksm_vm_flags_mod(unsigned long *vm_flags_p)
+{
+	if (uksm_flags_can_scan(*vm_flags_p))
+		*vm_flags_p |= VM_MERGEABLE;
+}
 
 /*
  * Just a wrapper for BUG_ON for where ksm_zeropage must not be. TODO: it will
@@ -108,6 +122,15 @@ static inline void uksm_cow_pte(struct vm_area_struct *vma, pte_t pte)
 {
 }
 
+static inline int uksm_flags_can_scan(unsigned long vm_flags)
+{
+	return 0;
+}
+
+static inline void uksm_vm_flags_mod(unsigned long *vm_flags_p)
+{
+}
+
 static inline void uksm_bugon_zeropage(pte_t pte)
 {
 }
diff --git a/mm/mmap.c b/mm/mmap.c
index 482c503..76cf74c 100644
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -1006,6 +1006,9 @@ unsigned long do_mmap_pgoff(struct file *file, unsigned long addr,
 	vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags) |
 			mm->def_flags | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC;
 
+	/* If uksm is enabled, we add VM_MERGABLE to new VMAs. */
+	uksm_vm_flags_mod(&vm_flags);
+
 	if (flags & MAP_LOCKED)
 		if (!can_do_mlock())
 			return -EPERM;
@@ -2156,6 +2159,7 @@ unsigned long do_brk(unsigned long addr, unsigned long len)
 		return error;
 
 	flags = VM_DATA_DEFAULT_FLAGS | VM_ACCOUNT | mm->def_flags;
+	uksm_vm_flags_mod(&flags);
 
 	error = get_unmapped_area(NULL, addr, len, 0, MAP_FIXED);
 	if (error & ~PAGE_MASK)
diff --git a/mm/uksm.c b/mm/uksm.c
index e123a6e..805eeab 100644
--- a/mm/uksm.c
+++ b/mm/uksm.c
@@ -958,11 +958,7 @@ failout_up:
  */
 static inline int vma_can_enter(struct vm_area_struct *vma)
 {
-	return !(vma->vm_flags & (VM_PFNMAP | VM_IO  | VM_DONTEXPAND |
-				  VM_RESERVED  | VM_HUGETLB | VM_INSERTPAGE |
-				  VM_NONLINEAR | VM_MIXEDMAP | VM_SAO |
-				  VM_SHARED  | VM_MAYSHARE | VM_GROWSUP
-				  | VM_GROWSDOWN));
+	return uksm_flags_can_scan(vma->vm_flags);
 }
 
 /*
-- 
1.7.9.5

